
// Author    KMS - Martin Dubois, P. Eng.
// Copyright (C) 2022 KMS
// License   http://www.apache.org/licenses/LICENSE-2.0
// Product   KMS-Framework
// File      KMS-A/Cfg_Configurator.cpp

// TODO Do not read the same configuration file twice.

#include "Component.h"

// ===== Includes ===========================================================
#include <KMS/Convert.h>
#include <KMS/DI/Alias.h>
#include <KMS/DI/Array_Sparse.h>
#include <KMS/DI/Boolean.h>
#include <KMS/DI/MetaData.h>
#include <KMS/DI/String.h>
#include <KMS/Environment.h>
#include <KMS/Text/TextFile.h>

#include <KMS/Cfg/Configurator.h>

// Constants
// //////////////////////////////////////////////////////////////////////////

#define FMT_ATT "%[A-Za-z0-9_]"
#define FMT_VAL "%[^\n\r\t]"

// Static function declarations
// //////////////////////////////////////////////////////////////////////////

static KMS::DI::Object* FindObject_Dictionary(KMS::DI::Dictionary* aD, const char* aA);

static void Help_Dictionary(FILE* aOut, const KMS::DI::Dictionary* aD, unsigned int aLevel);
static void Help_Object    (FILE* aOut, const KMS::DI::Object    * aO, unsigned int aLevel);

static void Save_Array     (FILE* aOut, const KMS::DI::Array     * aA, const char* aPrefix);
static void Save_Dictionary(FILE* aOut, const KMS::DI::Dictionary* aD, const char* aPrefix);
static void Save_Object    (FILE* aOut, const KMS::DI::Object    * aO, const char* aPrefix);
static void Save_Value     (FILE* aOut, const KMS::DI::Value     * aV, const char* aPrefix);

namespace KMS
{
    namespace Cfg
    {

        // Public
        // //////////////////////////////////////////////////////////////////

        Configurator::Configurator() : mIgnoredCount(0) {}

        void Configurator::AddConfigurable(DI::Dictionary* aD) { assert(NULL != aD); mConfigurables.push_back(aD); }

        void Configurator::AddConfigFile(const char* aPath)
        {
            ParseFile(File::Folder(File::Folder::Id::NONE), aPath, true);
        }

        void Configurator::AddOptionalConfigFile(const char* aPath)
        {
            ParseFile(File::Folder(File::Folder::Id::NONE), aPath);
        }

        unsigned int Configurator::GetIgnoredCount() const { return mIgnoredCount; }

        void Configurator::Help(FILE* aOut) const
        {
            FILE* lOut = (NULL == aOut) ? stdout : aOut;

            for (DI::Dictionary* lD : mConfigurables)
            {
                Help_Dictionary(lOut, lD, 0);
            }

            fprintf(lOut,
                "===== KMS::Cfg::Configurator =====\n"
                "  ConfigFile\t\tConfigFile += {FileName}\n"
                "  Help\t\t\tHelp\n"
                "  OptionalConfigFile\tOptionalConfigFile += {FileName}\n"
                "  SaveConfig\t\tSaveConfig = {FileName}\n");
        }

        void Configurator::ParseArguments(int aCount, const char** aVector)
        {
            assert(NULL != aVector);

            for (int i = 0; i < aCount; i++)
            {
                ParseLine(aVector[i]);
            }
        }

        void Configurator::ParseFile(const File::Folder& aFolder, const char* aFile, bool aMandatory)
        {
            if (aMandatory || aFolder.DoesFileExist(aFile))
            {
                Text::TextFile lTF;

                lTF.Read(aFolder, aFile);

                lTF.RemoveEmptyLines();
                lTF.RemoveComments_Script();

                for (std::string lLine : lTF.mLines)
                {
                    ParseLine(lLine.c_str());
                }
            }
        }

        void Configurator::Save(const char* aFileName)
        {
            FILE* lFile;

            errno_t lErr = fopen_s(&lFile, aFileName, "wb");
            KMS_EXCEPTION_ASSERT(0 == lErr, FILE_OPEN, "Cannot open the file to save the configuration");

            fprintf(lFile,
                "\n"
                "# Configuration file generated by the KMS::Cfg::Configurator class\n"
                "\n");

            for (DI::Dictionary* lD : mConfigurables)
            {
                Save_Dictionary(lFile, lD, "");
            }

            int lRet = fclose(lFile);
            assert(0 == lRet);
        }

        // Private
        // //////////////////////////////////////////////////////////////////

        void Configurator::AddValueToArray(const char* aA, const char* aV)
        {
            KMS::DI::Object* lObject = FindObject(aA);
            if (NULL == lObject)
            {
                // The name does not exist
                if (0 == strcmp("ConfigFile", aA))
                {
                    AddConfigFile(aV);
                }
                else if (0 == strcmp("OptionalConfigFile", aA))
                {
                    AddOptionalConfigFile(aV);
                }
                else
                {
                    KMS_DBG_LOG_WARNING();
                    goto Ignored;
                }
            }
            else
            {
                DI::Array* lArray = dynamic_cast<DI::Array*>(lObject);
                if (NULL == lArray)
                {
                    // The Object is not an Array
                    // TODO Should we throw an exception?
                    KMS_DBG_LOG_WARNING();
                    goto Ignored;
                }

                lObject = lArray->CreateEntry(&DI::META_DATA_DELETE_OBJECT);
                KMS_EXCEPTION_ASSERT(NULL != lObject, CONFIG_FORMAT, "The Array is not dynamic");

                DI::Value* lValue = dynamic_cast<DI::Value*>(lObject);
                KMS_EXCEPTION_ASSERT(NULL != lValue, CONFIG_FORMAT, "The Array element type is not supported");

                lValue->Set(aV);
            }

            return;

        Ignored:
            Dbg::gLog.WriteMessage(aA);
            Dbg::gLog.WriteMessage(aV);
            mIgnoredCount++;
        }

        void Configurator::AddValueToArray(const char* aA, const char* aI, const char* aV)
        {
            KMS::DI::Object* lObject = FindObject(aA);
            if (NULL == lObject)
            {
                KMS_DBG_LOG_WARNING();
                goto Ignored;
            }

            DI::Array* lArray;
            lArray = dynamic_cast<DI::Array*>(lObject);
            if (NULL == lArray)
            {
                // The Object is not an Array
                // TODO Should we throw an exception?
                KMS_DBG_LOG_WARNING();
                goto Ignored;
            }

            lObject = (*lArray)[aI];
            if (NULL == lObject)
            {
                lObject = lArray->CreateEntry(aI, NULL, DI::MetaData::FLAG_COPY_NAME);
                KMS_EXCEPTION_ASSERT(NULL != lObject, CONFIG_FORMAT, "The Array is not dynamic");
            }

            lArray = dynamic_cast<DI::Array*>(lObject);
            KMS_EXCEPTION_ASSERT(NULL != lArray, CONFIG_FORMAT, "The Object is not an Array");

            lObject = lArray->CreateEntry(&DI::META_DATA_DELETE_OBJECT);
            DI::Value* lValue;
            lValue = dynamic_cast<DI::Value*>(lObject);

            lValue->Set(aV);

            return;

        Ignored:
            Dbg::gLog.WriteMessage(aA);
            Dbg::gLog.WriteMessage(aI);
            Dbg::gLog.WriteMessage(aV);
            mIgnoredCount++;
        }

        void Configurator::ParseLine(const char* aLine)
        {
            assert(NULL != aLine);

            char lA[NAME_LENGTH];
            char lI[NAME_LENGTH];
            char lV[LINE_LENGTH];

            unsigned int lIndex;

            if (3 == sscanf_s(aLine, FMT_ATT "[ " FMT_ATT " ] += " FMT_VAL, lA SizeInfo(lA), lI SizeInfo(lI), lV SizeInfo(lV)))
            {
                AddValueToArray(lA, lI, lV); return;
            }

            if (3 == sscanf_s(aLine, FMT_ATT "[ %u ] = " FMT_VAL, lA SizeInfo(lA), &lIndex, lV SizeInfo(lV)))
            {
                SetArrayValue(lA, lIndex, lV); return;
            }

            if (3 == sscanf_s(aLine, FMT_ATT "[ " FMT_ATT " ] = " FMT_VAL, lA SizeInfo(lA), lI SizeInfo(lI), lV SizeInfo(lV)))
            {
                SetArrayValue(lA, lI, lV); return;
            }

            if (2 == sscanf_s(aLine, FMT_ATT " += " FMT_VAL, lA SizeInfo(lA), lV SizeInfo(lV))) { AddValueToArray(lA, lV); return; }

            if (2 == sscanf_s(aLine, FMT_ATT " = "  FMT_VAL, lA SizeInfo(lA), lV SizeInfo(lV))) { SetValue(lA, lV); return; }

            if (1 == sscanf_s(aLine, FMT_ATT, lA SizeInfo(lA))) { SetBoolean(aLine); return; }

            KMS_EXCEPTION_WITH_INFO(CONFIG_FORMAT, "Invalid configuration format", aLine);
        }

        DI::Object* Configurator::FindObject(const char* aA)
        {
            DI::Object* lResult = NULL;

            for (DI::Dictionary* lD : mConfigurables)
            {
                lResult = FindObject_Dictionary(lD, aA);
                if (NULL != lResult)
                {
                    DI::Alias* lAlias = dynamic_cast<DI::Alias*>(lResult);
                    if (NULL != lAlias)
                    {
                        lResult = lAlias->Get();
                    }

                    break;
                }
            }

            return lResult;
        }

        void Configurator::SetBoolean(const char* aA)
        {
            assert(NULL != aA);

            KMS::DI::Object* lObject = FindObject(aA);
            if (NULL == lObject)
            {
                // The name does not exist
                if (0 != strcmp("Help", aA))
                {
                    KMS_DBG_LOG_WARNING();
                    goto Ignored;
                }

                Help();
                exit(0);
            }

            DI::Boolean* lBoolean;
            
            lBoolean = dynamic_cast<DI::Boolean*>(lObject);
            if (NULL == lBoolean)
            {
                // The Object is not a Boolean
                // TODO Should we throw an exception?
                KMS_DBG_LOG_WARNING();
                goto Ignored;
            }

            *lBoolean = true;

            return;

        Ignored:
            Dbg::gLog.WriteMessage(aA);
            mIgnoredCount++;
        }

        void Configurator::SetArrayValue(const char* aA, const char* aI, const char* aV)
        {
            DI::Object* lObject = FindObject(aA);
            if (NULL == lObject)
            {
                // The name does not exist
                KMS_DBG_LOG_WARNING();
                goto Ignored;
            }

            DI::Array* lArray;
            
            lArray = dynamic_cast<DI::Array*>(lObject);
            if (NULL == lArray)
            {
                // The Object is not an Array
                // TODO Should we throw an exception?
                KMS_DBG_LOG_WARNING();
                goto Ignored;
            }

            lObject = (*lArray)[aI];
            if (NULL == lObject)
            {
                lObject = (*lArray)[aI];
            }

            if (NULL == lObject)
            {
                lObject = lArray->CreateEntry(aI, NULL, DI::MetaData::FLAG_COPY_NAME);
                KMS_EXCEPTION_ASSERT(NULL != lObject, CONFIG_FORMAT, "The Array is not dynamic");

                DI::Value* lValue = dynamic_cast<DI::Value*>(lObject);
                KMS_EXCEPTION_ASSERT(NULL != lValue, CONFIG_FORMAT, "The Array entry type is not supported");

                lValue->Set(aV);
            }
            else
            {
                DI::Value* lValue = dynamic_cast<DI::Value*>(lObject);
                if (NULL == lValue)
                {
                    // The Object is not a Value
                    // TODO Should we throw an exception?
                    KMS_DBG_LOG_WARNING();
                    goto Ignored;
                }

                lValue->Set(aV);
            }

            return;

        Ignored:
            Dbg::gLog.WriteMessage(aA);
            Dbg::gLog.WriteMessage(aI);
            Dbg::gLog.WriteMessage(aV);
            mIgnoredCount++;
        }

        void Configurator::SetArrayValue(const char* aA, unsigned int aI, const char* aV)
        {
            DI::Object* lObject = FindObject(aA);
            if (NULL == lObject)
            {
                // The name does not exist
                KMS_DBG_LOG_WARNING();
                goto Ignored;
            }

            DI::Array* lArray;

            lArray = dynamic_cast<DI::Array*>(lObject);
            if (NULL == lArray)
            {
                DI::Array_Sparse* lArrayS = dynamic_cast<DI::Array_Sparse*>(lObject);
                if (NULL == lArrayS)
                {
                    // The Object is not an Array
                    // TODO Should we throw an exception?
                    KMS_DBG_LOG_WARNING();
                    goto Ignored;
                }

                lObject = (*lArrayS)[aI];
                if (NULL == lObject)
                {
                    lObject = lArrayS->CreateEntry(aI, &DI::META_DATA_DELETE_OBJECT);
                    KMS_EXCEPTION_ASSERT(NULL != lObject, CONFIG_FORMAT, "The Array is not dynamic");
                }
            }
            else
            {
                lObject = (*lArray)[aI];
                if (NULL == lObject)
                {
                    lObject = lArray->CreateEntry(&DI::META_DATA_DELETE_OBJECT);
                    KMS_EXCEPTION_ASSERT(NULL != lObject, CONFIG_FORMAT, "The Array is not dynamic");
                }
            }

            DI::Value* lValue;
            
            lValue = dynamic_cast<DI::Value*>(lObject);
            KMS_EXCEPTION_ASSERT(NULL != lValue, CONFIG_FORMAT, "The Array entry type is not supported");

            lValue->Set(aV);

            return;

        Ignored:
            Dbg::gLog.WriteMessage(aA);
            Dbg::gLog.WriteMessage(aV);
            mIgnoredCount++;
        }

        void Configurator::SetValue(const char* aA, const char* aV)
        {
            KMS::DI::Object* lObject = FindObject(aA);
            if (NULL == lObject)
            {
                // The name does not exist
                if (0 != strcmp("SaveConfig", aA))
                {
                    KMS_DBG_LOG_WARNING();
                    goto Ignored;
                }

                Save(aV);
            }
            else
            {
                DI::Value* lValue;

                lValue = dynamic_cast<DI::Value*>(lObject);
                if (NULL == lValue)
                {
                    // The Object is not a Value
                    // TODO Should we throw an exception?
                    KMS_DBG_LOG_WARNING();
                    goto Ignored;
                }

                lValue->Set(aV);
            }
            
            return;

        Ignored:
            Dbg::gLog.WriteMessage(aA);
            Dbg::gLog.WriteMessage(aV);
            mIgnoredCount++;
        }

    }
}

// Static functions
// //////////////////////////////////////////////////////////////////////////

KMS::DI::Object* FindObject_Dictionary(KMS::DI::Dictionary* aD, const char* aA)
{
    assert(NULL != aD);

    char lB[NAME_LENGTH];

    const char* lEntryName = aA;

    if (aD->IsNamed())
    {
        char lA[NAME_LENGTH];

        if (2 == sscanf_s(aA, "%[^.].%s", lA SizeInfo(lA), lB SizeInfo(lB)))
        {
            if (!aD->Is(lA))
            {
                return NULL;
            }

            lEntryName = lB;
        }
    }

    KMS::DI::Dictionary::Internal& lInternal = aD->GetInternal();
    for (KMS::DI::Object* lObj : lInternal)
    {
        assert(NULL != lObj);

        if (lObj->Is(lEntryName))
        {
            return lObj;
        }

        KMS::DI::Dictionary* lD = dynamic_cast<KMS::DI::Dictionary*>(lObj);
        if (NULL != lD)
        {
            KMS::DI::Object* lResult = FindObject_Dictionary(lD, lEntryName);
            if (NULL != lResult)
            {
                return lResult;
            }
        }
    }

    return NULL;
}

void Help_Dictionary(FILE* aOut, const KMS::DI::Dictionary* aD, unsigned int aLevel)
{
    assert(NULL != aOut);
    assert(NULL != aD);

    Help_Object(aOut, aD, aLevel);

    const KMS::DI::Dictionary::Internal& lInternal = aD->GetInternal();
    for (const KMS::DI::Object* lObj : lInternal)
    {
        assert(NULL != lObj);

        const KMS::DI::Dictionary* lD = dynamic_cast<const KMS::DI::Dictionary*>(lObj);
        if (NULL == lD)
        {
            Help_Object(aOut, lObj, aLevel + 1);
        }
        else
        {
            Help_Dictionary(aOut, lD, aLevel + 1);
        }
    }
}

void Help_Object(FILE* aOut, const KMS::DI::Object* aO, unsigned int aLevel)
{
    assert(NULL != aOut);
    assert(NULL != aO);

    if (aO->IsNamed())
    {
        if (aO->IsLabeled())
        {
            fprintf(aOut, "%*c%s\t%s\n", aLevel * 2, ' ', aO->GetName(), aO->GetLabel());
        }
        else
        {
            fprintf(aOut, "%*c%s\n", aLevel * 2, ' ', aO->GetName());
        }
    }
    else
    {
        if (aO->IsLabeled())
        {
            fprintf(aOut, "%*c===== %s =====\n", aLevel * 2, ' ', aO->GetLabel());
        }
    }
}

void Save_Array(FILE* aOut, const KMS::DI::Array* aA, const char* aPrefix)
{
    assert(NULL != aOut);
    assert(NULL != aA);
    assert(NULL != aPrefix);

    if (aA->IsNamed())
    {
        const KMS::DI::Array::Internal& lInternal = aA->GetInternal();
        for (const KMS::DI::Object* lObj : lInternal)
        {
            assert(NULL != lObj);

            const KMS::DI::Value* lV = dynamic_cast<const KMS::DI::Value*>(lObj);
            KMS_EXCEPTION_ASSERT(NULL != lV, CONFIG_FORMAT, "Can't save part of the configuration");

            char lData[LINE_LENGTH];

            lV->Get(lData, sizeof(lData));

            fprintf(aOut, "%s%s += %s", aPrefix, aA->GetName(), lData);
        }
    }
}

void Save_Dictionary(FILE* aOut, const KMS::DI::Dictionary* aD, const char* aPrefix)
{
    assert(NULL != aD);
    assert(NULL != aPrefix);

    char lPrefix[LINE_LENGTH];

    if (aD->IsNamed())
    {
        sprintf_s(lPrefix, "%s%s.", aPrefix, aD->GetName());
    }
    else
    {
        sprintf_s(lPrefix, "%s", aPrefix);
    }

    const KMS::DI::Dictionary::Internal& lInternal = aD->GetInternal();
    for (const KMS::DI::Object* lObj : lInternal)
    {
        Save_Object(aOut, lObj, lPrefix);
    }
}

void Save_Object(FILE* aOut, const KMS::DI::Object* aO, const char* aPrefix)
{
    assert(NULL != aO);

    const KMS::DI::Dictionary* lD = dynamic_cast<const KMS::DI::Dictionary*>(aO);
    if (NULL == lD)
    {
        const KMS::DI::Array* lA = dynamic_cast<const KMS::DI::Array*>(aO);
        if (NULL == lA)
        {
            const KMS::DI::Value* lV = dynamic_cast<const KMS::DI::Value*>(aO);
            KMS_EXCEPTION_ASSERT(NULL != lV, CONFIG_FORMAT, "Can't save part of the configuration");

            Save_Value(aOut, lV, aPrefix);
        }
        else
        {
            Save_Array(aOut, lA, aPrefix);
        }
    }
    else
    {
        Save_Dictionary(aOut, lD, aPrefix);
    }
}

void Save_Value(FILE* aOut, const KMS::DI::Value* aV, const char* aPrefix)
{
    assert(NULL != aV);

    if (aV->IsNamed())
    {
        char lData[LINE_LENGTH];

        aV->Get(lData, sizeof(lData));

        fprintf(aOut, "%s%s = %s\n", aPrefix, aV->GetName(), lData);
    }
}
