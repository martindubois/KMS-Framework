
// Author    KMS - Martin Dubois, P. Eng.
// Copyright (C) 2022 KMS
// License   http://www.apache.org/licenses/LICENSE-2.0
// Product   KMS-Framework
// File      KMS-A/Cfg_Configurator.cpp

// TODO Do not read the same configuration file twice.

#include "Component.h"

// ===== Includes ===========================================================
#include <KMS/Cfg/MetaData.h>
#include <KMS/DI/Array.h>
#include <KMS/DI/Array_Sparse.h>
#include <KMS/DI/Boolean.h>
#include <KMS/DI/String.h>
#include <KMS/Text/TextFile.h>

#include <KMS/Cfg/Configurator.h>

// Constants
// //////////////////////////////////////////////////////////////////////////

#define FMT_ATT "%[A-Za-z0-9_.]"
#define FMT_IDX "%[A-Za-z0-9_]"
#define FMT_VAL "%[^\n\r\t]"

// Static function declarations
// //////////////////////////////////////////////////////////////////////////

static KMS::DI::Object* FindObject_Dictionary(KMS::DI::Dictionary* aD, const char* aA);

static void Help_Dictionary(FILE* aOut, const char* aName, const KMS::Cfg::MetaData* aMD, const KMS::DI::Dictionary* aD, unsigned int aLevel);
static void Help_Object    (FILE* aOut, const char* aName, const KMS::Cfg::MetaData* aMD,                                unsigned int aLevel);

static void Save_Array     (FILE* aOut, const KMS::DI::Array     * aA, const char* aName);
static void Save_Dictionary(FILE* aOut, const KMS::DI::Dictionary* aD, const char* aName);
static void Save_Object    (FILE* aOut, const KMS::DI::Object    * aO, const char* aName);
static void Save_Value     (FILE* aOut, const KMS::DI::Value     * aV, const char* aName);

namespace KMS
{
    namespace Cfg
    {

        // Public
        // //////////////////////////////////////////////////////////////////

        Configurator::Configurator() : mIgnoredCount(0) {}

        void Configurator::AddConfigurable(DI::Dictionary* aD) { assert(NULL != aD); mConfigurables.push_back(aD); }

        void Configurator::AddConfigFile(const char* aPath)
        {
            ParseFile(File::Folder(File::Folder::Id::NONE), aPath, true);
        }

        void Configurator::AddOptionalConfigFile(const char* aPath)
        {
            ParseFile(File::Folder(File::Folder::Id::NONE), aPath);
        }

        unsigned int Configurator::GetIgnoredCount() const { return mIgnoredCount; }

        void Configurator::Help(FILE* aOut) const
        {
            FILE* lOut = (NULL == aOut) ? stdout : aOut;

            for (DI::Dictionary* lD : mConfigurables)
            {
                Help_Dictionary(lOut, NULL, NULL, lD, 0);
            }

            fprintf(lOut,
                "===== KMS::Cfg::Configurator =====\n"
                "  ConfigFile += {FileName}\n"
                "  Help\n"
                "  OptionalConfigFile += {FileName}\n"
                "  SaveConfig = {FileName}\n");
        }

        void Configurator::ParseArguments(int aCount, const char** aVector)
        {
            assert(NULL != aVector);

            for (int i = 0; i < aCount; i++)
            {
                ParseLine(aVector[i]);
            }
        }

        void Configurator::ParseFile(const File::Folder& aFolder, const char* aFile, bool aMandatory)
        {
            if (aMandatory || aFolder.DoesFileExist(aFile))
            {
                Text::TextFile lTF;

                lTF.Read(aFolder, aFile);

                lTF.RemoveEmptyLines();
                lTF.RemoveComments_Script();

                for (std::string lLine : lTF.mLines)
                {
                    ParseLine(lLine.c_str());
                }
            }
        }

        void Configurator::Save(const char* aFileName)
        {
            FILE* lFile;

            errno_t lErr = fopen_s(&lFile, aFileName, "wb");
            KMS_EXCEPTION_ASSERT(0 == lErr, FILE_OPEN, "Cannot open the file to save the configuration");

            fprintf(lFile,
                "\n"
                "# Configuration file generated by the KMS::Cfg::Configurator class\n"
                "\n");

            for (DI::Dictionary* lD : mConfigurables)
            {
                Save_Dictionary(lFile, lD, NULL);
            }

            int lRet = fclose(lFile);
            assert(0 == lRet);
        }

        // Private
        // //////////////////////////////////////////////////////////////////

        void Configurator::AddValueToArray(const char* aA, const char* aV)
        {
            KMS::DI::Object* lObject = FindObject(aA);
            if (NULL == lObject)
            {
                // The name does not exist
                if (0 == strcmp("ConfigFile", aA))
                {
                    AddConfigFile(aV);
                }
                else if (0 == strcmp("OptionalConfigFile", aA))
                {
                    AddOptionalConfigFile(aV);
                }
                else
                {
                    KMS_DBG_LOG_WARNING();
                    goto Ignored;
                }
            }
            else
            {
                DI::Array* lArray = dynamic_cast<DI::Array*>(lObject);
                if (NULL == lArray)
                {
                    // The Object is not an Array
                    // TODO Should we throw an exception?
                    KMS_DBG_LOG_WARNING();
                    goto Ignored;
                }

                lObject = lArray->CreateEntry();
                assert(NULL != lObject);

                DI::Value* lValue = dynamic_cast<DI::Value*>(lObject);
                KMS_EXCEPTION_ASSERT(NULL != lValue, CONFIG_FORMAT, "The Array element type is not supported");

                lValue->Set(aV);
            }

            return;

        Ignored:
            Dbg::gLog.WriteMessage(aA);
            Dbg::gLog.WriteMessage(aV);
            mIgnoredCount++;
        }

        void Configurator::AddValueToArray(const char* aA, const char* aI, const char* aV)
        {
            KMS::DI::Object* lObject = FindObject(aA);
            if (NULL == lObject)
            {
                KMS_DBG_LOG_WARNING();
                goto Ignored;
            }

            DI::Dictionary* lDictionary;
            lDictionary = dynamic_cast<DI::Dictionary*>(lObject);
            if (NULL == lDictionary)
            {
                // The Object is not a Dictionary
                // TODO Should we throw an exception?
                KMS_DBG_LOG_WARNING();
                goto Ignored;
            }

            lObject = lDictionary->GetEntry_RW(aI);
            if (NULL == lObject)
            {
                lObject = lDictionary->CreateEntry(aI);
                assert(NULL != lObject);
            }

            DI::Array* lArray;
            lArray = dynamic_cast<DI::Array*>(lObject);
            KMS_EXCEPTION_ASSERT(NULL != lArray, CONFIG_FORMAT, "The Object is not an Array");

            lObject = lArray->CreateEntry();
            DI::Value* lValue;
            lValue = dynamic_cast<DI::Value*>(lObject);
            KMS_EXCEPTION_ASSERT(NULL != lValue, CONFIG_FORMAT, "The created Object is not a Value");

            lValue->Set(aV);

            return;

        Ignored:
            Dbg::gLog.WriteMessage(aA);
            Dbg::gLog.WriteMessage(aI);
            Dbg::gLog.WriteMessage(aV);
            mIgnoredCount++;
        }

        void Configurator::ParseLine(const char* aLine)
        {
            assert(NULL != aLine);

            char lA[NAME_LENGTH];
            char lI[NAME_LENGTH];
            char lV[LINE_LENGTH];

            unsigned int lIndex;

            if (3 == sscanf_s(aLine, FMT_ATT "[ " FMT_IDX " ] += " FMT_VAL, lA SizeInfo(lA), lI SizeInfo(lI), lV SizeInfo(lV)))
            {
                AddValueToArray(lA, lI, lV); return;
            }

            if (3 == sscanf_s(aLine, FMT_ATT "[ %u ] = " FMT_VAL, lA SizeInfo(lA), &lIndex, lV SizeInfo(lV)))
            {
                SetArrayValue(lA, lIndex, lV); return;
            }

            if (3 == sscanf_s(aLine, FMT_ATT "[ " FMT_IDX " ] = " FMT_VAL, lA SizeInfo(lA), lI SizeInfo(lI), lV SizeInfo(lV)))
            {
                SetDictionaryValue(lA, lI, lV); return;
            }

            if (2 == sscanf_s(aLine, FMT_ATT " += " FMT_VAL, lA SizeInfo(lA), lV SizeInfo(lV))) { AddValueToArray(lA, lV); return; }

            if (2 == sscanf_s(aLine, FMT_ATT " = "  FMT_VAL, lA SizeInfo(lA), lV SizeInfo(lV))) { SetValue(lA, lV); return; }

            if (1 == sscanf_s(aLine, FMT_ATT, lA SizeInfo(lA))) { SetBoolean(aLine); return; }

            KMS_EXCEPTION_WITH_INFO(CONFIG_FORMAT, "Invalid configuration format", aLine);
        }

        DI::Object* Configurator::FindObject(const char* aA)
        {
            DI::Object* lResult = NULL;

            for (DI::Dictionary* lD : mConfigurables)
            {
                lResult = FindObject_Dictionary(lD, aA);
                if (NULL != lResult)
                {
                    break;
                }
            }

            return lResult;
        }

        void Configurator::SetBoolean(const char* aA)
        {
            assert(NULL != aA);

            KMS::DI::Object* lObject = FindObject(aA);
            if (NULL == lObject)
            {
                // The name does not exist
                if (0 != strcmp("Help", aA))
                {
                    KMS_DBG_LOG_WARNING();
                    goto Ignored;
                }

                Help();
                exit(0);
            }

            DI::Boolean* lBoolean;
            
            lBoolean = dynamic_cast<DI::Boolean*>(lObject);
            if (NULL == lBoolean)
            {
                // The Object is not a Boolean
                // TODO Should we throw an exception?
                KMS_DBG_LOG_WARNING();
                goto Ignored;
            }

            *lBoolean = true;

            return;

        Ignored:
            Dbg::gLog.WriteMessage(aA);
            mIgnoredCount++;
        }

        void Configurator::SetArrayValue(const char* aA, unsigned int aI, const char* aV)
        {
            DI::Object* lObject = FindObject(aA);
            if (NULL == lObject)
            {
                // The name does not exist
                KMS_DBG_LOG_WARNING();
                goto Ignored;
            }

            DI::Array* lArray;
            lArray = dynamic_cast<DI::Array*>(lObject);
            if (NULL == lArray)
            {
                DI::Array_Sparse* lArrayS = dynamic_cast<DI::Array_Sparse*>(lObject);
                if (NULL == lArrayS)
                {
                    // The Object is not an Array
                    // TODO Should we throw an exception?
                    KMS_DBG_LOG_WARNING();
                    goto Ignored;
                }

                lObject = lArrayS->GetEntry_RW(aI);
                if (NULL == lObject)
                {
                    lObject = lArrayS->CreateEntry(aI);
                }
            }
            else
            {
                lObject = lArray->GetEntry_RW(aI);
                if (NULL == lObject)
                {
                    lObject = lArray->CreateEntry();
                }
            }

            assert(NULL != lArray);

            DI::Value* lValue;
            lValue = dynamic_cast<DI::Value*>(lObject);
            KMS_EXCEPTION_ASSERT(NULL != lValue, CONFIG_FORMAT, "The Array entry type is not supported");

            lValue->Set(aV);

            return;

        Ignored:
            Dbg::gLog.WriteMessage(aA);
            Dbg::gLog.WriteMessage(aV);
            mIgnoredCount++;
        }

        void Configurator::SetDictionaryValue(const char* aA, const char* aI, const char* aV)
        {
            DI::Object* lObject = FindObject(aA);
            if (NULL == lObject)
            {
                // The name does not exist
                KMS_DBG_LOG_WARNING();
                goto Ignored;
            }

            DI::Dictionary* lDictionary;

            lDictionary = dynamic_cast<DI::Dictionary*>(lObject);
            if (NULL == lDictionary)
            {
                // The Object is not an Array
                // TODO Should we throw an exception?
                KMS_DBG_LOG_WARNING();
                goto Ignored;
            }


            lObject = lDictionary->GetEntry_RW(aI);
            if (NULL == lObject)
            {
                lObject = lDictionary->CreateEntry(aI);
                assert(NULL != lObject);
            }

            DI::Value* lValue;
            lValue = dynamic_cast<DI::Value*>(lObject);
            KMS_EXCEPTION_ASSERT(NULL != lValue, CONFIG_FORMAT, "The Array entry type is not supported");

            lValue->Set(aV);

            return;

        Ignored:
            Dbg::gLog.WriteMessage(aA);
            Dbg::gLog.WriteMessage(aI);
            Dbg::gLog.WriteMessage(aV);
            mIgnoredCount++;
        }

        void Configurator::SetValue(const char* aA, const char* aV)
        {
            KMS::DI::Object* lObject = FindObject(aA);
            if (NULL == lObject)
            {
                // The name does not exist
                if (0 != strcmp("SaveConfig", aA))
                {
                    KMS_DBG_LOG_WARNING();
                    goto Ignored;
                }

                Save(aV);
            }
            else
            {
                DI::Value* lValue;

                lValue = dynamic_cast<DI::Value*>(lObject);
                if (NULL == lValue)
                {
                    // The Object is not a Value
                    // TODO Should we throw an exception?
                    KMS_DBG_LOG_WARNING();
                    goto Ignored;
                }

                lValue->Set(aV);
            }
            
            return;

        Ignored:
            Dbg::gLog.WriteMessage(aA);
            Dbg::gLog.WriteMessage(aV);
            mIgnoredCount++;
        }

    }
}

// Static functions
// //////////////////////////////////////////////////////////////////////////

KMS::DI::Object* FindObject_Dictionary(KMS::DI::Dictionary* aD, const char* aA)
{
    assert(NULL != aD);

    char lA[NAME_LENGTH];
    char lB[NAME_LENGTH];

    KMS::DI::Object* lResult = NULL;

    int lRet = sscanf_s(aA, "%[^.].%s", lA SizeInfo(lA), lB SizeInfo(lB));
    switch (lRet)
    {
    case 1: lResult = aD->GetEntry_RW(aA); break;

    case 2:
        KMS::DI::Object * lObject;
        lObject = aD->GetEntry_RW(lA);
        if (NULL != lObject)
        {
            KMS::DI::Dictionary* lDictionary = dynamic_cast<KMS::DI::Dictionary*>(lObject);
            KMS_EXCEPTION_ASSERT(NULL != lDictionary, CONFIG_FORMAT, "The object is not a dictionary");

            lResult = FindObject_Dictionary(lDictionary, lB);
        }
        break;

    default: KMS_EXCEPTION_WITH_INFO(CONFIG_FORMAT, "Invalid attribute name", aA);
    }

    return lResult;
}

void Help_Dictionary(FILE* aOut, const char* aName, const KMS::Cfg::MetaData* aMD, const KMS::DI::Dictionary* aD, unsigned int aLevel)
{
    assert(NULL != aOut);
    assert(NULL != aD);

    Help_Object(aOut, aName, aMD, aLevel);

    const KMS::DI::Dictionary::Internal& lInternal = aD->GetInternal();
    for (const KMS::DI::Dictionary::Internal::value_type lVT : lInternal)
    {
        assert(NULL != lVT.second);

        const KMS::Cfg::MetaData * lMD = dynamic_cast<const KMS::Cfg::MetaData *>(lVT.second.mMetaData);
        const KMS::DI::Dictionary* lD  = dynamic_cast<const KMS::DI::Dictionary*>(lVT.second.Get());
        if (NULL == lD)
        {
            Help_Object(aOut, lVT.first.c_str(), lMD, aLevel + 1);
        }
        else
        {
            Help_Dictionary(aOut, lVT.first.c_str(), lMD, lD, aLevel + 1);
        }
    }
}

void Help_Object(FILE* aOut, const char* aName, const KMS::Cfg::MetaData* aMD, unsigned int aLevel)
{
    assert(NULL != aOut);

    if (NULL != aMD)
    {
        fprintf(aOut, "%*c%s\n", aLevel * 2, ' ', aMD->GetHelp());
    }
    else if (NULL != aName)
    {
        fprintf(aOut, "%*c%s\n", aLevel * 2, ' ', aName);
    }
}

void Save_Array(FILE* aOut, const KMS::DI::Array* aA, const char* aName)
{
    assert(NULL != aOut);
    assert(NULL != aA);
    assert(NULL != aName);

    const KMS::DI::Array::Internal& lInternal = aA->GetInternal();
    for (const KMS::DI::Container::Entry& lEntry : lInternal)
    {
        assert(NULL != lEntry);

        const KMS::DI::Value* lV = dynamic_cast<const KMS::DI::Value*>(lEntry.Get());
        KMS_EXCEPTION_ASSERT(NULL != lV, CONFIG_FORMAT, "Can't save part of the configuration");

        char lData[LINE_LENGTH];

        lV->Get(lData, sizeof(lData));

        fprintf(aOut, "%s += %s", aName, lData);
    }
}

void Save_Dictionary(FILE* aOut, const KMS::DI::Dictionary* aD, const char* aName)
{
    assert(NULL != aD);

    const KMS::DI::Dictionary::Internal& lInternal = aD->GetInternal();
    for (const KMS::DI::Dictionary::Internal::value_type lVT : lInternal)
    {
        assert(NULL != lVT.second);

        if (NULL == aName)
        {
            Save_Object(aOut, lVT.second.Get(), lVT.first.c_str());
        }
        else
        {
            char lName[NAME_LENGTH];

            sprintf_s(lName, "%s.%s", aName, lVT.first.c_str());

            Save_Object(aOut, lVT.second.Get(), lName);
        }
    }
}

void Save_Object(FILE* aOut, const KMS::DI::Object* aO, const char* aName)
{
    assert(NULL != aO);

    const KMS::DI::Dictionary* lD = dynamic_cast<const KMS::DI::Dictionary*>(aO);
    if (NULL == lD)
    {
        const KMS::DI::Array* lA = dynamic_cast<const KMS::DI::Array*>(aO);
        if (NULL == lA)
        {
            const KMS::DI::Value* lV = dynamic_cast<const KMS::DI::Value*>(aO);
            KMS_EXCEPTION_ASSERT(NULL != lV, CONFIG_FORMAT, "Can't save part of the configuration");

            Save_Value(aOut, lV, aName);
        }
        else
        {
            Save_Array(aOut, lA, aName);
        }
    }
    else
    {
        Save_Dictionary(aOut, lD, aName);
    }
}

void Save_Value(FILE* aOut, const KMS::DI::Value* aV, const char* aName)
{
    assert(NULL != aV);
    assert(NULL != aName);

    char lData[LINE_LENGTH];

    aV->Get(lData, sizeof(lData));

    fprintf(aOut, "%s = %s\n", aName, lData);
}
