
// Author    KMS - Martin Dubois, P. Eng.
// Copyright (C) 2022 KMS
// License   http://www.apache.org/licenses/LICENSE-2.0
// Product   KMS-Framework
// File      KMS-A/Cfg_Configurator.cpp

// TEST COVERAGE 2022-10-28 KMS - Martin Dubois, P. Eng.

// TODO Do not read the same configuration file twice.

#include "Component.h"

// ===== Includes ===========================================================
#include <KMS/Cfg/MetaData.h>
#include <KMS/DI/Array.h>
#include <KMS/DI/Array_Sparse.h>
#include <KMS/DI/Boolean.h>
#include <KMS/DI/Functions.h>
#include <KMS/DI/String.h>
#include <KMS/Text/File_ASCII.h>

#include <KMS/Cfg/Configurator.h>

// Constants
// //////////////////////////////////////////////////////////////////////////

#define FMT_ATT "%[A-Za-z0-9_.]"
#define FMT_IDX "%[A-Za-z0-9_]"
#define FMT_VAL "%[^\n\r\t]"

// Static function declarations
// //////////////////////////////////////////////////////////////////////////

static void Help_Dictionary(FILE* aOut, const char* aName, const KMS::Cfg::MetaData* aMD, const KMS::DI::Dictionary* aD, unsigned int aLevel);
static void Help_Object    (FILE* aOut, const char* aName, const KMS::Cfg::MetaData* aMD,                                unsigned int aLevel);

static void Save_Array     (FILE* aOut, const KMS::DI::Array     * aA, const char* aName);
static void Save_Dictionary(FILE* aOut, const KMS::DI::Dictionary* aD, const char* aName);
static void Save_Object    (FILE* aOut, const KMS::DI::Object    * aO, const char* aName);
static void Save_Value     (FILE* aOut, const KMS::DI::Value     * aV, const char* aName);

namespace KMS
{
    namespace Cfg
    {

        // Public
        // //////////////////////////////////////////////////////////////////

        Configurator::Configurator() : mIgnoredCount(0) {}

        void Configurator::AddConfigurable(DI::Dictionary* aD) { assert(NULL != aD); mConfigurables.push_back(aD); }

        void Configurator::AddConfigFile(const char* aPath)
        {
            ParseFile(File::Folder(File::Folder::Id::NONE), aPath, true);
        }

        void Configurator::AddOptionalConfigFile(const char* aPath)
        {
            ParseFile(File::Folder(File::Folder::Id::NONE), aPath);
        }

        unsigned int Configurator::GetIgnoredCount() const { return mIgnoredCount; }

        void Configurator::Help(FILE* aOut) const
        {
            FILE* lOut = (NULL == aOut) ? stdout : aOut;

            for (DI::Dictionary* lD : mConfigurables)
            {
                Help_Dictionary(lOut, NULL, NULL, lD, 0);
            }

            fprintf(lOut,
                "===== KMS::Cfg::Configurator =====\n"
                "  ConfigFile += {FileName}\n"
                "  Help\n"
                "  OptionalConfigFile += {FileName}\n"
                "  SaveConfig = {FileName}\n");
        }

        void Configurator::ParseArguments(int aCount, const char** aVector)
        {
            assert(NULL != aVector);

            for (int i = 0; i < aCount; i++)
            {
                ParseLine(aVector[i]);
            }
        }

        void Configurator::ParseFile(const File::Folder& aFolder, const char* aFile, bool aMandatory)
        {
            if (aMandatory || aFolder.DoesFileExist(aFile))
            {
                Text::File_ASCII lTF;

                lTF.Read(aFolder, aFile);

                lTF.RemoveEmptyLines();
                lTF.RemoveComments_Script();

                for (std::string lLine : lTF.mLines)
                {
                    ParseLine(lLine.c_str());
                }
            }
        }

        void Configurator::Save(const char* aFileName)
        {
            FILE* lFile;

            errno_t lErr = fopen_s(&lFile, aFileName, "wb");
            KMS_EXCEPTION_ASSERT(0 == lErr, CFG_OPEN_FAILED, "Cannot open the file to save the configuration", aFileName);

            fprintf(lFile,
                "\n"
                "# Configuration file generated by the KMS::Cfg::Configurator class\n"
                "\n");

            for (DI::Dictionary* lD : mConfigurables)
            {
                Save_Dictionary(lFile, lD, NULL);
            }

            int lRet = fclose(lFile);
            assert(0 == lRet);
        }

        // Private
        // //////////////////////////////////////////////////////////////////

        void Configurator::ParseLine(const char* aLine)
        {
            assert(NULL != aLine);

            for (DI::Dictionary* lD : mConfigurables)
            {
                if (DI::Execute_Operation(lD, aLine))
                {
                    return;
                }
            }

            if (0 == strcmp("Help", aLine)) { Help(); exit(0); }

            char lFileName[PATH_LENGTH];

            if (1 == sscanf_s(aLine, "OptionalConfigFile += %[^ \n\r\t]", lFileName SizeInfo(lFileName))) { AddOptionalConfigFile(lFileName); return; }
            if (1 == sscanf_s(aLine, "ConfigFile += %[^ \n\r\t]", lFileName SizeInfo(lFileName))) { AddConfigFile(lFileName); return; }
            if (1 == sscanf_s(aLine, "SaveConfig = %[^ \n\r\t]", lFileName SizeInfo(lFileName))) { Save(lFileName); return; }

            // TODO Execute internal commands

            KMS_DBG_LOG_WARNING();
            Dbg::gLog.WriteMessage(aLine);
            mIgnoredCount++;
        }

    }
}

// Static functions
// //////////////////////////////////////////////////////////////////////////

void Help_Dictionary(FILE* aOut, const char* aName, const KMS::Cfg::MetaData* aMD, const KMS::DI::Dictionary* aD, unsigned int aLevel)
{
    assert(NULL != aOut);
    assert(NULL != aD);

    Help_Object(aOut, aName, aMD, aLevel);

    for (const KMS::DI::Dictionary::Internal::value_type lVT : aD->mInternal)
    {
        assert(NULL != lVT.second);

        const KMS::Cfg::MetaData * lMD = dynamic_cast<const KMS::Cfg::MetaData *>(lVT.second.mMetaData);
        const KMS::DI::Dictionary* lD  = dynamic_cast<const KMS::DI::Dictionary*>(lVT.second.Get());
        if (NULL == lD)
        {
            Help_Object(aOut, lVT.first.c_str(), lMD, aLevel + 1);
        }
        else
        {
            // NOT TESTED
            Help_Dictionary(aOut, lVT.first.c_str(), lMD, lD, aLevel + 1);
        }
    }
}

void Help_Object(FILE* aOut, const char* aName, const KMS::Cfg::MetaData* aMD, unsigned int aLevel)
{
    assert(NULL != aOut);

    if (NULL != aMD)
    {
        fprintf(aOut, "%*c%s\n", aLevel * 2, ' ', aMD->GetHelp());
    }
    else if (NULL != aName)
    {
        // NOT TESTED
        fprintf(aOut, "%*c%s\n", aLevel * 2, ' ', aName);
    }
}

void Save_Array(FILE* aOut, const KMS::DI::Array* aA, const char* aName)
{
    assert(NULL != aOut);
    assert(NULL != aA);
    assert(NULL != aName);

    for (const KMS::DI::Container::Entry& lEntry : aA->mInternal)
    {
        assert(NULL != lEntry);

        const KMS::DI::Value* lV = dynamic_cast<const KMS::DI::Value*>(lEntry.Get());
        KMS_EXCEPTION_ASSERT(NULL != lV, CFG_FORMAT_INVALID, "Can't save part of the configuration", aName);

        char lData[LINE_LENGTH];

        lV->Get(lData, sizeof(lData));

        fprintf(aOut, "%s += %s", aName, lData);
    }
}

void Save_Dictionary(FILE* aOut, const KMS::DI::Dictionary* aD, const char* aName)
{
    assert(NULL != aD);

    for (const KMS::DI::Dictionary::Internal::value_type lVT : aD->mInternal)
    {
        assert(NULL != lVT.second);

        if (NULL == aName)
        {
            Save_Object(aOut, lVT.second.Get(), lVT.first.c_str());
        }
        else
        {
            // NOT TESTED

            char lName[NAME_LENGTH];

            sprintf_s(lName, "%s.%s", aName, lVT.first.c_str());

            Save_Object(aOut, lVT.second.Get(), lName);
        }
    }
}

void Save_Object(FILE* aOut, const KMS::DI::Object* aO, const char* aName)
{
    assert(NULL != aO);

    const KMS::DI::Dictionary* lD = dynamic_cast<const KMS::DI::Dictionary*>(aO);
    if (NULL == lD)
    {
        const KMS::DI::Array* lA = dynamic_cast<const KMS::DI::Array*>(aO);
        if (NULL == lA)
        {
            const KMS::DI::Value* lV = dynamic_cast<const KMS::DI::Value*>(aO);
            KMS_EXCEPTION_ASSERT(NULL != lV, CFG_FORMAT_INVALID, "Can't save part of the configuration", aName);

            Save_Value(aOut, lV, aName);
        }
        else
        {
            Save_Array(aOut, lA, aName);
        }
    }
    else
    {
        Save_Dictionary(aOut, lD, aName);
    }
}

void Save_Value(FILE* aOut, const KMS::DI::Value* aV, const char* aName)
{
    assert(NULL != aV);
    assert(NULL != aName);

    char lData[LINE_LENGTH];

    aV->Get(lData, sizeof(lData));

    fprintf(aOut, "%s = %s\n", aName, lData);
}
